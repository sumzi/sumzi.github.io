{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/useEffect-useLayoutEffect/","result":{"data":{"site":{"siteMetadata":{"title":"SUMZI Blog"}},"markdownRemark":{"id":"13f9cd77-f59b-581a-8edb-e97dee201b89","excerpt":"Render : DOM Tree 를 구성하기 위해 각 엘리먼트의 스타일 속성을 계산하는 과정 Paint : 실제 스크린에 Layout을 표시하고 업데이트하는 과정 useEffect 는 컴포넌트들이 render와 paint된 후 실행된다. 비동기적으로 실행된다. paint…","html":"<ul>\n<li>Render : DOM Tree 를 구성하기 위해 각 엘리먼트의 스타일 속성을 계산하는 과정</li>\n<li>Paint : 실제 스크린에 Layout을 표시하고 업데이트하는 과정</li>\n</ul>\n<h2>useEffect</h2>\n<ul>\n<li><code class=\"language-text\">useEffect</code>는 컴포넌트들이 render와 paint된 후 실행된다.</li>\n<li>비동기적으로 실행된다.</li>\n<li>paint 된 후 실행되기 때문에, <code class=\"language-text\">useEffect</code> 내부에 dom에 영향을 주는 코드가 있을 경우 사용자 입장에서는 화면의 깜빡임을 보게 된다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 411px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/982691af5408c14ece5f3f5a309cf80a/2a432/useeffect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.0379746835443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnklEQVQoz02PXVObUBCG8/9/QW96rZ06Nn6WZJIQMUZGC4GUI1C1OvlQiJhwOBwgcPZsh5im3Xlndi/22X3fRlLQf8opInqep2maYRjT6QQRpaxgvUJIakkG5QqqFDfVsGeWPbfGL/ZGVgH52B6rqqrrummaILHKAoyvo+dO+NgKHpRioUnmSAk1fO0Pj7SjZv+bavVI6ATL1+gtCsMwCIIwDBLG508WpjdjfV89/3TV/pzMVeQEQNSwv3D9N9dfuF5IvIBk69qS/LC16VAuITHKpZG8DvPoVlKzYj6AlBIbAgSAACkAJeyoOmpdHyNAhSgZi2n8zjnbHW9sdysBaSo4B85FmgrGoCjwv/9SYplXZS4mz7Oc5VBKUUEDN+fz6YRqfa4P6UBjw0E60PgdkX8tIOJ7uLrp2qNLMtKIqTnWJdFboy3Mnn77p8e/lO/m4YFz3HxQzu973SiKGGOUUp7xyeOsuXd2uHdydtA6+ao0v5y29i+28PplTjvtuNdJ1C5Vu6u2krlkFx0R0zgzVWKqZNS/sy7cH72fztX9HzU155qIUASBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"useEffect\"\n        title=\"useEffect\"\n        src=\"/static/982691af5408c14ece5f3f5a309cf80a/2a432/useeffect.png\"\n        srcset=\"/static/982691af5408c14ece5f3f5a309cf80a/c26ae/useeffect.png 158w,\n/static/982691af5408c14ece5f3f5a309cf80a/6bdcf/useeffect.png 315w,\n/static/982691af5408c14ece5f3f5a309cf80a/2a432/useeffect.png 411w\"\n        sizes=\"(max-width: 411px) 100vw, 411px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>상태변화가 있으면 렌더링이 시작된다. 컴포넌트가 렌더되고 렌더된 컴포넌트가 스크린에 그려진다. 그다음 <code class=\"language-text\">useEffect</code>가 실행된다.</p>\n<h2>useLayoutEffect</h2>\n<ul>\n<li><code class=\"language-text\">useLayoutEffect</code> 는 컴포넌트들이 render된 후 실행되며, 그 이후에 paint가 된다.</li>\n<li>동기적으로 실행된다.</li>\n<li>paint가 되기전에 실행되기 때문에 dom을 조작하는 코드가 존재하더라도 사용자는 깜빡임을 경험하지 않는다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 501px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bc5dc8d5f92b78f594babbf9c424b2b5/55811/uselayouteffect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.44303797468354%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABVklEQVQY0z3M2U7CQBgFYN7/PYxbjELQC6OCIChSsC1MiWxpLO0MA6XQhXbW34DLuThX5zulVbJcJctwvw7363VKaUyYZAihRqNh27YQEkSqCx84AUYOzbEuKGgNACXT75veR81+erIeu/OOFZj+ZjGbzoZoaNvWJoqz0Nl59/7nLZnc4fEdHld52AHFD9ghQ4eg3tzoTjuDhY3wIExXAKBBA2ilQaRfOW1Hi+YueEnI685viq0JSoCGEhNFIXKumDi8iULzI4OjP7aWWuUAvMh3nMWCJwD8Z1CCv3BKJQ7UcikJFgQzHGgl/1/izX5LsxDH7sRPIxavs4gmf1hK+tbunp4Y56fW1WXv4ix4uI88r+A8z/M0ybwRsdsj49l6r30YdcvpTlFr9ou1UpnZdys30/K1W6241fK2WU9XVEjJOWcFc1FgNkZGbdCrD/vPaND6dF5n3wsJfHx9Z3aqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"useLayoutEffect\"\n        title=\"useLayoutEffect\"\n        src=\"/static/bc5dc8d5f92b78f594babbf9c424b2b5/55811/uselayouteffect.png\"\n        srcset=\"/static/bc5dc8d5f92b78f594babbf9c424b2b5/c26ae/uselayouteffect.png 158w,\n/static/bc5dc8d5f92b78f594babbf9c424b2b5/6bdcf/uselayouteffect.png 315w,\n/static/bc5dc8d5f92b78f594babbf9c424b2b5/55811/uselayouteffect.png 501w\"\n        sizes=\"(max-width: 501px) 100vw, 501px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>상태변화가 있으면 렌더링이 시작된다. 컴포넌트가 렌더링되면 <code class=\"language-text\">useLayoutEffect</code>가 실행된다. 그리고 렌더된 컴포넌트가 스크린에 그려진다.</p>\n<h2>리액트 컴포넌트 렌더링</h2>\n<h3>재렌더링 케이스</h3>\n<p>react 컴포넌트는 4가지 상황에서 재렌더링 된다.</p>\n<ol>\n<li>내부 상태값(state) 변경</li>\n<li>부모가 전해준 속성(props) 변경</li>\n<li>중앙 상태값(redux store 등) 변경</li>\n<li>부모 컴포넌트가 재렌더링되는 경우, 자식 컴포넌트도 재렌더링</li>\n</ol>\n<p>컴포넌트가 렌더링되면, 해당 컴포넌트 함수가 호출되어 화면을 다시 그린다.</p>\n<h3>React 마운트 과정</h3>\n<ol>\n<li>함수 컴포넌트 호출</li>\n<li>구현부 실행\n<ul>\n<li>props 취득, hook 실행, 내부 변수 및 함수 생성</li>\n<li>단, hook에 등록해준 상태값, 부수 함수 효과 등은 별도 메모리에 저장되어 관리됨</li>\n</ul>\n</li>\n<li>return 실행\n<ul>\n<li>렌더링 시작</li>\n</ul>\n</li>\n<li>렌더 단계 (Render Phase)\n<ul>\n<li>가상 DOM을 생성</li>\n</ul>\n</li>\n<li>커밋 단계 (Commit Phase)\n<ul>\n<li>실제 DOM에 반영한다.</li>\n</ul>\n</li>\n<li>useLayoutEffect\n<ul>\n<li>브라우저가 화면에 페인트하기 전에, useLayoutEffect에 등록해둔 effect가 동기로 실행된다.</li>\n<li>이때 state, redux store 등의 변경이 있다면 한번 더 재렌더링된다.</li>\n</ul>\n</li>\n<li>Paint\n<ul>\n<li>브라우저가 실제 DOM을 화면에 그린다. didMount가 완료된다.</li>\n</ul>\n</li>\n<li>useEffect\n<ul>\n<li>Mount되어 화면이 그려진 직후, useEffect에 등록해둔 effect가 비동기로 실행된다.</li>\n</ul>\n</li>\n</ol>\n<h3>React 재렌더링 과정</h3>\n<ol>\n<li>함수 컴포넌트 재호출</li>\n<li>구현부 실행\n<ul>\n<li>props 취득, hook 실행, 내부 변수 및 함수 재생성</li>\n<li>단, 각 hook의 특성에 따라 기존에 메모리에 저장한 내용을 적절히 활용한다.</li>\n</ul>\n</li>\n<li>return 실행\n<ul>\n<li>렌더링 시작</li>\n</ul>\n</li>\n<li>렌더 단계 (Render Phase)\n<ul>\n<li>새로운 가상 DOM생성 후, 이전 가상 DOM과 비교하여, 달라진 부분을 탐색하고, 실제 DOM에 반영할 부분을 결정한다.</li>\n</ul>\n</li>\n<li>커밋 단계 (Commit Phase)\n<ul>\n<li>달라진 부분만 실제 DOM에 반영한다.</li>\n</ul>\n</li>\n<li>useLayoutEffect\n<ul>\n<li>브라우저가 화면에 Paint 하기 전에, useLayoutEffect에 등록해둔 effect가 동기로 실행된다.</li>\n<li>이때, state, redux store 등의 변경이 있다면 한번 더 재렌더링된다.</li>\n</ul>\n</li>\n<li>Paint\n<ul>\n<li>브라우저가 실제 DOM을 화면에 그린다. didUpdate가 완료된다.</li>\n</ul>\n</li>\n<li>useEffect\n<ul>\n<li>update되어 화면이 그려진 직후, useEffect에 등록해둔 effect가 비동기로 실행된다.</li>\n<li>effect에 return 부분이 있다면, 구현부보다 먼저 실행된다.</li>\n</ul>\n</li>\n</ol>\n<h2>결론</h2>\n<p><code class=\"language-text\">useLayoutEffect</code>는 동기적으로 실행되고 내부의 코드가 모두 실행된 후 painting 작업을 거친다. 따라서 로직이 복잡할 경우 사용자가 레이아웃을 보는데까지 시간이 오래걸린다는 단점이 있어서 기본적으로 항상 <code class=\"language-text\">useEffect</code>만을 사용하는 것을 권장한다.</p>\n<br/>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://medium.com/@jnso5072/react-useeffect-%EC%99%80-uselayouteffect-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-e1a13adf1cd5\">https://medium.com/@jnso5072/react-useeffect-와-uselayouteffect-의-차이는-무엇일까-e1a13adf1cd5</a></li>\n<li><a href=\"https://curryyou.tistory.com/486\">https://curryyou.tistory.com/486</a></li>\n</ul>","frontmatter":{"title":"useEffect와 useLayoutEffect의 차이","date":"November 11, 2022","description":null,"category":"react"}},"previous":{"fields":{"slug":"/web/performance-optimization/"},"frontmatter":{"title":"성능 최적화"}},"next":{"fields":{"slug":"/javascript/this/"},"frontmatter":{"title":"this"}}},"pageContext":{"id":"13f9cd77-f59b-581a-8edb-e97dee201b89","previousPostId":"315d1b17-5ef9-5fad-8dfa-da38d14e9dc3","nextPostId":"20d963e0-38cc-55b0-af1f-06b7d9d8426e"}},"staticQueryHashes":["2841359383","3274528899"]}