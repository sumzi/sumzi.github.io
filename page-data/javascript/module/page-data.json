{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/module/","result":{"data":{"site":{"siteMetadata":{"title":"SUMZI Blog"}},"markdownRemark":{"id":"0789f316-cab7-572b-a8a5-6206686b887e","excerpt":"여러 기능들에 관한 코드가 모여있는 하나의 파일 시스템을 이루는 논리적인 일부분 장점 유지보수성 네임스페이스화 재사용성 모듈이 없다면? 전역 스코프 오염 예측하기 어렵고 오류를 만든다. 변수 충돌, 로딩 순서 취약 IIFE…","html":"<ul>\n<li>여러 기능들에 관한 코드가 모여있는 하나의 파일</li>\n<li>시스템을 이루는 논리적인 일부분</li>\n<li>장점\n<ul>\n<li>유지보수성</li>\n<li>네임스페이스화</li>\n<li>재사용성</li>\n</ul>\n</li>\n</ul>\n<h2>모듈이 없다면?</h2>\n<ul>\n<li>전역 스코프 오염</li>\n<li>예측하기 어렵고 오류를 만든다.</li>\n<li>변수 충돌, 로딩 순서 취약</li>\n</ul>\n<h2>IIFE 방식의 모듈</h2>\n<ul>\n<li>위의 문제를 예방하기 위해 스코프를 사용한다.</li>\n<li>함수 스코프를 만들어 외부에서 안으로 접근하지 못하도록 공간을 격리한다.</li>\n<li>스코프 외부로부터 독립적인 스코프를 만들어 사용하여 전역변수 오염을 방지한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var math = math || {} // math 네임스페이스\n\n(function () {\n  function sum(a, b) {\n    return a + b\n  }\n  math.sum = sum // 네임스페이스에 추가\n})()</code></pre></div>\n<h2>다양한 모듈 스펙</h2>\n<h3>CommonJs</h3>\n<ul>\n<li>자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표</li>\n<li><code class=\"language-text\"> module.exports</code> 키워드로 모듈을 만들고 <code class=\"language-text\">require()</code> 함수로 불러 들이는 방식</li>\n<li>모든 파일이 로컬에 존재하여 바로 불러올 수 있음을 전제로 하며, 동기적으로 동작한다.</li>\n<li>대표적으로 서버 사이트 플랫폼인 <code class=\"language-text\">Node.js</code>에서 이를 사용한다.</li>\n</ul>\n<h3>AMD</h3>\n<ul>\n<li>Asynchronous Module Definition</li>\n<li>CommonJS 그룹에서 의견이 맞지 않아 나온 사람들이 만든 그룹으로 비동기 모듈에 대한 표준안을 다루는 그룹이다.</li>\n<li>브라우저 내의 실행에 중점을 두고, 비동기로 로딩되는 환경에서 모듈을 사용하는 것이 목표다.</li>\n<li><code class=\"language-text\">define</code>, <code class=\"language-text\">require</code> 함수를 이용한다.</li>\n<li>구현한 유명한 스크립트가 <code class=\"language-text\">RequireJS</code>가 있다.</li>\n</ul>\n<h3>UMD</h3>\n<ul>\n<li>Universal Module Definition</li>\n<li>AMD기반으로 CommonJS 방식까지 지원하는 통합 형태다.</li>\n</ul>\n<h2>ESM(ECMAScript Module)</h2>\n<ul>\n<li>자바스크립트에서 모듈 사용 가능하다.</li>\n<li><code class=\"language-text\">export</code> 구문으로 모듈을 만들고 <code class=\"language-text\">import</code> 구문으로 가져올 수 있다.</li>\n<li><code class=\"language-text\">&lt;script></code>태그로 로딩할 때 <code class=\"language-text\">type=\"module\"</code>을 사용한다.</li>\n<li>독자적인 모듈 스코프를 갖는다.</li>\n<li>모든 파일을 네트워크 통신을 통해 가져와야한다.\n<ul>\n<li>파일을 하나하나 가져옴</li>\n<li>js뿐만 아니라 css, 이미지, font 파일도 있음</li>\n</ul>\n</li>\n<li>모듈 번들러가 필요하다…</li>\n</ul>\n<h2>Module Bundler</h2>\n<ul>\n<li>웹 애플리케이션을 구성하는 자원(HTML, CSS, JS, Image 등)을 모두 각각의 모듈로 보고, 이를 조합해서 병합된 하나의 결과물을 만드는 도구다.</li>\n</ul>\n<h2>Webpack</h2>\n<ul>\n<li>프론트엔드 프레임워크에서 많이 사용되는 모듈 번들러이다.</li>\n<li>의존 관계를 가지고 있는 javascript, css, image 등의 리소스드를 하나의 파일로 번들링하게 도와준다.</li>\n</ul>\n<h3>webpack이 해결하려는 문제</h3>\n<ol>\n<li>\n<p>자바스크립트 스코프</p>\n<ul>\n<li>여러개의 자바스크립트에서 파일에서 선언된 변수와 함수들이 전역적으로 설정되면 그만큼 충돌이나 로딩 순서 등에 취약하다.</li>\n<li>이를 모듈이라는 단위로 관리할 수 있게 도와준다.</li>\n</ul>\n</li>\n<li>\n<p>브라우저별 HTTP 요청 숫자의 제약</p>\n<ul>\n<li>브라우저에서 한번에 서버로 보낼 수 있는 HTTP 요청 숫자는 제약되어 있다.</li>\n<li>웹팩을 통해 번들링하면 요청해야하는 파일의 수가 적어지므로 더 빠른 성능 개선이 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>Dynamic Loading &#x26; Lazy Loading</p>\n<ul>\n<li>SPA의 단점으로 초기에 필요하지 않은 페이지에 대한 스크립트들도 불러온다.</li>\n<li>웹팩을 통해 모듈 번들링을 이용하면 동적으로, 필요한 페이지에 따른 스크립트 모듈을 동적으로 불러오는 것도 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>웹 개발 작업 자동화</p>\n<ul>\n<li>HTML, CSS, JS 압축</li>\n<li>이미지 압축</li>\n<li>CSS 전처리기 변환</li>\n</ul>\n</li>\n</ol>\n<h3>entry/output</h3>\n<ul>\n<li><code class=\"language-text\">--mode</code>, <code class=\"language-text\">--entry</code>, <code class=\"language-text\">--output</code> 세 개 옵션만 사용하면 코드를 묶을 수 있다.</li>\n<li><code class=\"language-text\">--mode</code>: 웹팩 실행 모드를 의미, development, production, null이 있음</li>\n<li><code class=\"language-text\">--entry</code>: 시작점 경로를 지정하는 옵션</li>\n<li><code class=\"language-text\">--output</code>: 번들링 결과물을 위치할 경로</li>\n</ul>\n<h3>Loader</h3>\n<ul>\n<li>웹팩이 자바스크립트 파일이 아닌 웹자원(HTML, CSS, image, font)을 변환할 수 있도록 도와준다.</li>\n<li><code class=\"language-text\">css-loader</code> : css 파일을 모듈로서 가져올 수 있다.</li>\n<li><code class=\"language-text\">style-loader</code> : css를 html에 넣어 브라우저 렌더링 시 적용될 수 있게 해준다.</li>\n<li><code class=\"language-text\">file-loader</code> : 이미지를 모듈로 가져올 수 있다.</li>\n</ul>\n<h3>Plugin</h3>\n<ul>\n<li>로더가 해석하고 변환한 결과물의 형태를 바꾼다. 즉, 후처리하는 역할</li>\n<li>난독화, 특정 문자열 치환 등을 할 수 있다.</li>\n<li><code class=\"language-text\">defineplugin</code> : 환경 의존적인 정보를 관리</li>\n</ul>\n<h2>Babel</h2>\n<ul>\n<li>서로 다른 브라우저 스펙으로 인해 하나의 프로젝트 코드로 모든 브라우저를 커버하지 못하게 되는 크로스 브라우징 문제를 해결해준다.</li>\n<li>최신 스펙을 사용해서 코드를 작성해도 브라우저마다 동일하게 동작하도록 도와준다.</li>\n<li>코드 변환 3단계\n<ol>\n<li>토큰 분해</li>\n<li>ES5 스펙으로 변환</li>\n<li>코드 출력</li>\n</ol>\n</li>\n</ul>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html\">https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html</a></li>\n<li><a href=\"https://medium.com/@chullino/%EC%9B%B9%ED%8C%A9-3-4-js%EB%AA%A8%EB%93%88%ED%99%94-%EC%97%AD%EC%82%AC-%EB%8F%8C%EC%95%84%EB%B3%B4%EA%B8%B0-1-9df997f82002\">https://medium.com/@chullino/%EC%9B%B9%ED%8C%A9-3-4-js%EB%AA%A8%EB%93%88%ED%99%94-%EC%97%AD%EC%82%AC-%EB%8F%8C%EC%95%84%EB%B3%B4%EA%B8%B0-1-9df997f82002</a></li>\n<li><a href=\"https://poiemaweb.com/es6-module\">https://poiemaweb.com/es6-module</a></li>\n</ul>","frontmatter":{"title":"모듈","date":"October 23, 2022","description":null,"category":"javascript"}},"previous":{"fields":{"slug":"/web/ci-cd/"},"frontmatter":{"title":"CI와 CD"}},"next":{"fields":{"slug":"/web/browser-rendering/"},"frontmatter":{"title":"브라우저 렌더링 과정"}}},"pageContext":{"id":"0789f316-cab7-572b-a8a5-6206686b887e","previousPostId":"0c041ab9-6528-50e7-b376-b1d25e15a8bc","nextPostId":"e9cbaeef-de0b-5f01-a50b-661dd7948ece"}},"staticQueryHashes":["2841359383","3274528899"]}