<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[Gatsby Starter Blog RSS Feed]]></description><link>https://sumzi.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 15 Nov 2022 05:54:05 GMT</lastBuildDate><item><title><![CDATA[this]]></title><description><![CDATA[this 란? this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. this가 가리키는 값, 즉 this…]]></description><link>https://sumzi.github.io/javascript/this/</link><guid isPermaLink="false">https://sumzi.github.io/javascript/this/</guid><pubDate>Tue, 15 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;this 란?&lt;/h2&gt;
&lt;p&gt;this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.&lt;/p&gt;
&lt;p&gt;this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;this 바인딩&lt;/strong&gt;
바인딩이란 식별자와 값을 연결하는 과정을 의미한다.
ex) 변수 선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩하는 것이다.
this 바인딩은 this(키워드로 분류되지만 식별자 역할을 한다)와 this가 가리킬 객체를 바인딩하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;렉시컬 함수 : 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다.&lt;/li&gt;
&lt;li&gt;this 바인딩 : 함수 호출 시점에 결정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;함수를 호출하는 방식&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;일반 함수 호출&lt;/li&gt;
&lt;li&gt;메서드 호출&lt;/li&gt;
&lt;li&gt;생성자 함수 호출&lt;/li&gt;
&lt;li&gt;apply/call/bind 메서드에 의한 간접 호출&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;1. 일반 함수 호출&lt;/h3&gt;
&lt;p&gt;기본적으로 this에는 전역 객체가 바인딩된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;foo&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// window&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;bar&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// window&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩딘다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.&lt;/p&gt;
&lt;h3&gt;2. 메서드 호출&lt;/h3&gt;
&lt;p&gt;메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다.&lt;/p&gt;
&lt;p&gt;주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 &lt;strong&gt;메서드를 호출한 객체에 바인딩된다는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; person &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Ji&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Ji&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 생성자 함수 호출&lt;/h3&gt;
&lt;p&gt;생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;radius&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; radius
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;getDiameter&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; circle1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; circle2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;circle1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getDiameter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 10&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;circle2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getDiameter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. apply/call/bind 메서드에 의한 간접 호출&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getThisBinding&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arguments&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [Arguments] { &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3 }&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; thisArg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token literal-property property&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getThisBinding&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// window&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getThisBinding&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;thisArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {a:1}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getThisBinding&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;thisArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {a:1}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getThisBinding&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;thisArg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {a:1}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;apply 와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. 함수를 호출하면 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.&lt;/p&gt;
&lt;p&gt;apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.&lt;/p&gt;
&lt;p&gt;call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Lee&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; person &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Ji&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Hi! my name is &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Hi! my name is Ji.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Hi! my name is &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Hi! my name is Lee.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 화살표함수를 사용한다면 bind 메서드를 사용할 수 없다.&lt;/p&gt;
&lt;p&gt;메서드로 정의한 화살표 함수 내부의 this는 메소드를 소유한 객체, 즉 메소드를 호출한 객체를 가리키지 않고 상위 컨텍스트인 전역 객체 window를 가리킨다. 따라서 화살표 함수로 메소드를 정의하는 것은 바람직하지 않다.&lt;/p&gt;
&lt;h2&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/js-this&quot;&gt;https://poiemaweb.com/js-this&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.javascript.info/call-apply-decorators&quot;&gt;https://ko.javascript.info/call-apply-decorators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[useEffect와 useLayoutEffect의 차이]]></title><description><![CDATA[Render : DOM Tree 를 구성하기 위해 각 엘리먼트의 스타일 속성을 계산하는 과정 Paint : 실제 스크린에 Layout을 표시하고 업데이트하는 과정 useEffect 는 컴포넌트들이 render와 paint…]]></description><link>https://sumzi.github.io/react/useEffect-useLayoutEffect/</link><guid isPermaLink="false">https://sumzi.github.io/react/useEffect-useLayoutEffect/</guid><pubDate>Fri, 11 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;Render : DOM Tree 를 구성하기 위해 각 엘리먼트의 스타일 속성을 계산하는 과정&lt;/li&gt;
&lt;li&gt;Paint : 실제 스크린에 Layout을 표시하고 업데이트하는 과정&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;useEffect&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt;는 컴포넌트들이 render와 paint된 후 실행된다.&lt;/li&gt;
&lt;li&gt;비동기적으로 실행된다.&lt;/li&gt;
&lt;li&gt;paint 된 후 실행되기 때문에, &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt; 내부에 dom에 영향을 주는 코드가 있을 경우 사용자 입장에서는 화면의 깜빡임을 보게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 411px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/982691af5408c14ece5f3f5a309cf80a/2a432/useeffect.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.0379746835443%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnklEQVQoz02PXVObUBCG8/9/QW96rZ06Nn6WZJIQMUZGC4GUI1C1OvlQiJhwOBwgcPZsh5im3Xlndi/22X3fRlLQf8opInqep2maYRjT6QQRpaxgvUJIakkG5QqqFDfVsGeWPbfGL/ZGVgH52B6rqqrrummaILHKAoyvo+dO+NgKHpRioUnmSAk1fO0Pj7SjZv+bavVI6ATL1+gtCsMwCIIwDBLG508WpjdjfV89/3TV/pzMVeQEQNSwv3D9N9dfuF5IvIBk69qS/LC16VAuITHKpZG8DvPoVlKzYj6AlBIbAgSAACkAJeyoOmpdHyNAhSgZi2n8zjnbHW9sdysBaSo4B85FmgrGoCjwv/9SYplXZS4mz7Oc5VBKUUEDN+fz6YRqfa4P6UBjw0E60PgdkX8tIOJ7uLrp2qNLMtKIqTnWJdFboy3Mnn77p8e/lO/m4YFz3HxQzu973SiKGGOUUp7xyeOsuXd2uHdydtA6+ao0v5y29i+28PplTjvtuNdJ1C5Vu6u2krlkFx0R0zgzVWKqZNS/sy7cH72fztX9HzU155qIUASBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;useEffect&quot;
        title=&quot;useEffect&quot;
        src=&quot;/static/982691af5408c14ece5f3f5a309cf80a/2a432/useeffect.png&quot;
        srcset=&quot;/static/982691af5408c14ece5f3f5a309cf80a/c26ae/useeffect.png 158w,
/static/982691af5408c14ece5f3f5a309cf80a/6bdcf/useeffect.png 315w,
/static/982691af5408c14ece5f3f5a309cf80a/2a432/useeffect.png 411w&quot;
        sizes=&quot;(max-width: 411px) 100vw, 411px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;상태변화가 있으면 렌더링이 시작된다. 컴포넌트가 렌더되고 렌더된 컴포넌트가 스크린에 그려진다. 그다음 &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt;가 실행된다.&lt;/p&gt;
&lt;h2&gt;useLayoutEffect&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;useLayoutEffect&lt;/code&gt; 는 컴포넌트들이 render된 후 실행되며, 그 이후에 paint가 된다.&lt;/li&gt;
&lt;li&gt;동기적으로 실행된다.&lt;/li&gt;
&lt;li&gt;paint가 되기전에 실행되기 때문에 dom을 조작하는 코드가 존재하더라도 사용자는 깜빡임을 경험하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 501px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bc5dc8d5f92b78f594babbf9c424b2b5/55811/uselayouteffect.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 35.44303797468354%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABVklEQVQY0z3M2U7CQBgFYN7/PYxbjELQC6OCIChSsC1MiWxpLO0MA6XQhXbW34DLuThX5zulVbJcJctwvw7363VKaUyYZAihRqNh27YQEkSqCx84AUYOzbEuKGgNACXT75veR81+erIeu/OOFZj+ZjGbzoZoaNvWJoqz0Nl59/7nLZnc4fEdHld52AHFD9ghQ4eg3tzoTjuDhY3wIExXAKBBA2ilQaRfOW1Hi+YueEnI685viq0JSoCGEhNFIXKumDi8iULzI4OjP7aWWuUAvMh3nMWCJwD8Z1CCv3BKJQ7UcikJFgQzHGgl/1/izX5LsxDH7sRPIxavs4gmf1hK+tbunp4Y56fW1WXv4ix4uI88r+A8z/M0ybwRsdsj49l6r30YdcvpTlFr9ou1UpnZdys30/K1W6241fK2WU9XVEjJOWcFc1FgNkZGbdCrD/vPaND6dF5n3wsJfHx9Z3aqAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;useLayoutEffect&quot;
        title=&quot;useLayoutEffect&quot;
        src=&quot;/static/bc5dc8d5f92b78f594babbf9c424b2b5/55811/uselayouteffect.png&quot;
        srcset=&quot;/static/bc5dc8d5f92b78f594babbf9c424b2b5/c26ae/uselayouteffect.png 158w,
/static/bc5dc8d5f92b78f594babbf9c424b2b5/6bdcf/uselayouteffect.png 315w,
/static/bc5dc8d5f92b78f594babbf9c424b2b5/55811/uselayouteffect.png 501w&quot;
        sizes=&quot;(max-width: 501px) 100vw, 501px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;상태변화가 있으면 렌더링이 시작된다. 컴포넌트가 렌더링되면 &lt;code class=&quot;language-text&quot;&gt;useLayoutEffect&lt;/code&gt;가 실행된다. 그리고 렌더된 컴포넌트가 스크린에 그려진다.&lt;/p&gt;
&lt;h2&gt;리액트 컴포넌트 렌더링&lt;/h2&gt;
&lt;h3&gt;재렌더링 케이스&lt;/h3&gt;
&lt;p&gt;react 컴포넌트는 4가지 상황에서 재렌더링 된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내부 상태값(state) 변경&lt;/li&gt;
&lt;li&gt;부모가 전해준 속성(props) 변경&lt;/li&gt;
&lt;li&gt;중앙 상태값(redux store 등) 변경&lt;/li&gt;
&lt;li&gt;부모 컴포넌트가 재렌더링되는 경우, 자식 컴포넌트도 재렌더링&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;컴포넌트가 렌더링되면, 해당 컴포넌트 함수가 호출되어 화면을 다시 그린다.&lt;/p&gt;
&lt;h3&gt;React 마운트 과정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;함수 컴포넌트 호출&lt;/li&gt;
&lt;li&gt;구현부 실행
&lt;ul&gt;
&lt;li&gt;props 취득, hook 실행, 내부 변수 및 함수 생성&lt;/li&gt;
&lt;li&gt;단, hook에 등록해준 상태값, 부수 함수 효과 등은 별도 메모리에 저장되어 관리됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;return 실행
&lt;ul&gt;
&lt;li&gt;렌더링 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;렌더 단계 (Render Phase)
&lt;ul&gt;
&lt;li&gt;가상 DOM을 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;커밋 단계 (Commit Phase)
&lt;ul&gt;
&lt;li&gt;실제 DOM에 반영한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;useLayoutEffect
&lt;ul&gt;
&lt;li&gt;브라우저가 화면에 페인트하기 전에, useLayoutEffect에 등록해둔 effect가 동기로 실행된다.&lt;/li&gt;
&lt;li&gt;이때 state, redux store 등의 변경이 있다면 한번 더 재렌더링된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Paint
&lt;ul&gt;
&lt;li&gt;브라우저가 실제 DOM을 화면에 그린다. didMount가 완료된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;useEffect
&lt;ul&gt;
&lt;li&gt;Mount되어 화면이 그려진 직후, useEffect에 등록해둔 effect가 비동기로 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;React 재렌더링 과정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;함수 컴포넌트 재호출&lt;/li&gt;
&lt;li&gt;구현부 실행
&lt;ul&gt;
&lt;li&gt;props 취득, hook 실행, 내부 변수 및 함수 재생성&lt;/li&gt;
&lt;li&gt;단, 각 hook의 특성에 따라 기존에 메모리에 저장한 내용을 적절히 활용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;return 실행
&lt;ul&gt;
&lt;li&gt;렌더링 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;렌더 단계 (Render Phase)
&lt;ul&gt;
&lt;li&gt;새로운 가상 DOM생성 후, 이전 가상 DOM과 비교하여, 달라진 부분을 탐색하고, 실제 DOM에 반영할 부분을 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;커밋 단계 (Commit Phase)
&lt;ul&gt;
&lt;li&gt;달라진 부분만 실제 DOM에 반영한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;useLayoutEffect
&lt;ul&gt;
&lt;li&gt;브라우저가 화면에 Paint 하기 전에, useLayoutEffect에 등록해둔 effect가 동기로 실행된다.&lt;/li&gt;
&lt;li&gt;이때, state, redux store 등의 변경이 있다면 한번 더 재렌더링된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Paint
&lt;ul&gt;
&lt;li&gt;브라우저가 실제 DOM을 화면에 그린다. didUpdate가 완료된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;useEffect
&lt;ul&gt;
&lt;li&gt;update되어 화면이 그려진 직후, useEffect에 등록해둔 effect가 비동기로 실행된다.&lt;/li&gt;
&lt;li&gt;effect에 return 부분이 있다면, 구현부보다 먼저 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;useLayoutEffect&lt;/code&gt;는 동기적으로 실행되고 내부의 코드가 모두 실행된 후 painting 작업을 거친다. 따라서 로직이 복잡할 경우 사용자가 레이아웃을 보는데까지 시간이 오래걸린다는 단점이 있어서 기본적으로 항상 &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt;만을 사용하는 것을 권장한다.&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@jnso5072/react-useeffect-%EC%99%80-uselayouteffect-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-e1a13adf1cd5&quot;&gt;https://medium.com/@jnso5072/react-useeffect-와-uselayouteffect-의-차이는-무엇일까-e1a13adf1cd5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://curryyou.tistory.com/486&quot;&gt;https://curryyou.tistory.com/486&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[브라우저 렌더링 과정]]></title><description><![CDATA[…]]></description><link>https://sumzi.github.io/web/browser-rendering/</link><guid isPermaLink="false">https://sumzi.github.io/web/browser-rendering/</guid><pubDate>Sun, 06 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;브라우저는 유저가 선택한 장원을 서버로부터 받아와서 유저에게 보여준다. 자원은 페이지 외에도 이미지, 비디오 등의 컨텐츠들도 포함된다. 받아온 자원들을 렌더링 과정을 통해 유저에게 보여주게 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;브라우저 렌더링 동작 과정&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;HTML&lt;/code&gt;파일과 &lt;code class=&quot;language-text&quot;&gt;CSS&lt;/code&gt;파일을 파싱해서 각각 DOM Tree와 CSSOM Tree를 만든다. (Parsing)&lt;/li&gt;
&lt;li&gt;두 tree를 결합하여 Render Tree를 만든다. (Style)&lt;/li&gt;
&lt;li&gt;Render Tree에서 각 노드의 위치와 크기를 계산한다.(Layout)&lt;/li&gt;
&lt;li&gt;계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다. (Paint)&lt;/li&gt;
&lt;li&gt;레이어를 합성하여 실제 화면에 나타낸다. (Composite)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Parsing&lt;/h3&gt;
&lt;p&gt;브라우저가 페이지를 렌더링하려면 가장 먼저 받아온 HTML파일을 해석해야한다. Parsing 단계는 HTML파일을 해석하여 DOM(Document Object Model) Tree를 구성하는 단계이다.&lt;/p&gt;
&lt;p&gt;파싱 중 HTML에 CSS가 포함되어 있다면 CSSOM(CSS Object Model) Tree 구성 작업도 함께 진행한다.&lt;/p&gt;
&lt;h3&gt;Style&lt;/h3&gt;
&lt;p&gt;Parsing 단계에서 생성된 &lt;code class=&quot;language-text&quot;&gt;DOM Tree&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;CSSOM Tree&lt;/code&gt;를 매칭시켜서 &lt;code class=&quot;language-text&quot;&gt;Render Tree&lt;/code&gt;를 구성한다. 실제로 화면에 그려질 트리이다.&lt;/p&gt;
&lt;p&gt;렌더 트리를 구성할 때 &lt;code class=&quot;language-text&quot;&gt;visibility: hidden&lt;/code&gt; 요소가 공간을 차지하지만 보이지 않기 때문에 렌더 트리에 포함이되지만 &lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt;의 경우 공간을 차지하지 않기 때문에 렌더 트리에서 제외된다.&lt;/p&gt;
&lt;h3&gt;Layout&lt;/h3&gt;
&lt;p&gt;Layout 단계에서는 렌더 트리를 화면에 어떻게 배치해야 할 것인지 노드의 정확한 위치와 크기를 계산한다.&lt;/p&gt;
&lt;p&gt;루트 노드부터 순회하면서 노드의 정확한 크기와 위치를 계산하고 렌더 트리에 반영한다. 만약 크기 값을 %로 지정하였다면, Layout 단계에서 %값을 계산해서 픽셀 단위로 변환한다.&lt;/p&gt;
&lt;h3&gt;Paint&lt;/h3&gt;
&lt;p&gt;Paint 단계에서는 Layout 단계에서 계산된 값을 이용해 렌더 트리의 각 노드를 화면상의 실제 픽셀로 변환한다. 이때 픽셀로 변환된 결과는 하나의 레이어가 아니라 여러개의 레이어로 관리된다.&lt;/p&gt;
&lt;p&gt;스타일이 복잡할수록 Paint 시간도 늘어난다. 예를 들어 단색 배경의 경우 시간과 작업이 적게 필요하지만, 그림자 효과는 시간과 작업이 더 많이 필요하다.&lt;/p&gt;
&lt;h3&gt;Composite&lt;/h3&gt;
&lt;p&gt;Paint 단계에서 생성된 레이어를 합성하여 실제 화면에 나타낸다. 우리는 화면에서 웹페이지를 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Glossary/Browser&quot;&gt;https://developer.mozilla.org/ko/docs/Glossary/Browser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;https://d2.naver.com/helloworld/59361&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[성능 최적화]]></title><description><![CDATA[…]]></description><link>https://sumzi.github.io/web/performance-optimization/</link><guid isPermaLink="false">https://sumzi.github.io/web/performance-optimization/</guid><pubDate>Sun, 06 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;성능 최적화에 필요한 이론&lt;/h2&gt;
&lt;h3&gt;브라우저의 로딩 과정&lt;/h3&gt;
&lt;p&gt;브라우저는 웹 페이지에 필요한 리소스를 내려받고 해석한 다음 여러 계산 과정을 거쳐 콘텐츠를 화면에 보여준다. 이를 브라우저 로딩 과정이라고 하며 다운로드, 파싱, 스타일, 레이아웃, 페인트, 합성으로 나뉜다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파싱
&lt;ul&gt;
&lt;li&gt;파싱이 일어나면 HTML을 해석해 DOM을 생성한 후, 각 DOM 객체를 트리 데이터 구조로 연결해 부모-자식 관계를 만든다. &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&gt;, &amp;lt;p&gt;, &amp;lt;div&gt;&lt;/code&gt; 등 각 태그가 DOM 트리의 노드의 생성되고 자식 노드를 참조한다.&lt;/li&gt;
&lt;li&gt;style.css등 외부 스타일시트 파일이나 내부 스타일시트가 포함되어 있을 경우, CSS를 해석해 CSSOM 트리를 구성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스타일
&lt;ul&gt;
&lt;li&gt;파싱 단계에서 생성된 DOM, CSSOM 트리를 가지고 스타일을 매칭 시켜주는 과정을 거쳐 렌더 트리를 구성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;레이아웃
&lt;ul&gt;
&lt;li&gt;노드의 정확한 위치와 크기를 계산한다. 루트부터 노드를 순회하면서 계산하고, 레이아웃 결과로 각 노드의 정확한 위치와 크기를 픽셀값으로 렌더 트리에 반영한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;페인트
&lt;ul&gt;
&lt;li&gt;계산된 값을 이용해 렌더 트리의 각 노드를 화면상의 실제 픽셀로 변환한다. 이때 위치와 관계없는 CSS 속성을 적용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;합성, 렌더
&lt;ul&gt;
&lt;li&gt;페인트 단계에서 생성된 레이어를 합성하여 스크린을 업데이트 한다. 합성과 렌더 단계가 끝나면 화면에서 웹 페이지를 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;블록 리소스와 주요 렌더링 경로&lt;/h3&gt;
&lt;p&gt;브라우저 로딩 초기 단계에서 HTML 파싱이 일어날 때 CSS, JS로 인해 파싱이 중단될 수 있다. 이렇게 파싱이 중단되는 상황을 HTML 파싱이 블록되었다라고 표현하며, 블록 상태의 원인이 되는 리소스를 블록 리소스(Block resource)라고 부른다.&lt;/p&gt;
&lt;p&gt;블록 리소스는 브라우저 로딩 단계 중 페인트 과정을 지연시키므로, 블록 리소스가 HTML 파싱을 막는 상황이 발생하지 않도록 해야한다.&lt;/p&gt;
&lt;h3&gt;레아아웃과 리페인트&lt;/h3&gt;
&lt;p&gt;브라우저 로딩 과정 중 스타일 이후의 과정 (스타일→레이아웃→페인트→합성)을 렌더링이라고 하는데, 이 렌더링 과정은 상황에 따라 반복하여 발생할 수 있다. 스타일 단계에서 구성되는 렌더 트리는 자바스크립트에 의해 DOM트리, CSSOM트리가 변경될 때 다시 재구성된다. DOM이 추가, 삭제되거나 요소에 기하적인 영향(넓이, 높이, 위치)을 주는 CSS 속성값을 변경하는 경우 렌더 트리가 다시 재구성된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레이아웃부터 이후 과정을 다시 수행하며 이것을 &lt;strong&gt;레이아웃&lt;/strong&gt;(또는 리플로우)이라고 한다.&lt;/li&gt;
&lt;li&gt;레이아웃은 요소에 기하적인 영향을 주는 CSS 속성값을 변경할 때 발생하였는데, 반대로 영향을 주지 않는 CSS 속성값을 변경하면 레이아웃 과정을 건너 뛴다. 페인트부터 수행하며 이를 &lt;strong&gt;리페인트&lt;/strong&gt;라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;브라우저 기준의 성능 측정&lt;/h3&gt;
&lt;p&gt;전통적인 성능 측정 방식은 브라우저에서 발생하는 이벤트를 사용하는 것이었다. 웹 페이지가 로딩될 때 &lt;code class=&quot;language-text&quot;&gt;DOMContentLoaded&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;load&lt;/code&gt; 이벤트가 발생하며, 각 이벤트가 발생하는 시점으로 성능을 측정하게 된다. 두 이벤트 발생 시점이 빠를수록, 발생 구간의 폭이 좁을수록 성능이 좋다고 말한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOMContentLoaded 이벤트
&lt;ul&gt;
&lt;li&gt;HTML과 CSS 파싱이 끝나는 시점&lt;/li&gt;
&lt;li&gt;렌더 트리를 구성할 준비가 된 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;load 이벤트
&lt;ul&gt;
&lt;li&gt;HTML 상에 필요한 모든 리소스가 로드된 시점&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;내비게이션 타이밍 API 사용
&lt;ul&gt;
&lt;li&gt;이벤트 발생 시점을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;크롬 개발자 도구 사용
&lt;ul&gt;
&lt;li&gt;크롬 개발자 도구는 브라우저에서 이벤트 발생 시점을 확인할 수 있도록 UI를 제공하고 다양한 측정 방법을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용자 기준의 성능 측정
&lt;ul&gt;
&lt;li&gt;사용자 기준의 성능 측정은 사용자에게 콘텐츠를 보여주는 여러 시점을 기반으로 한다. 의미 있는 콘텐츠가 처음 보이는 시점이 빠를수록 성능이 좋다고 판단하며, 이 시점을 앞당길 수 있도록 최적화해야한다.&lt;/li&gt;
&lt;li&gt;구글에서 지정한 성능 시점
&lt;ul&gt;
&lt;li&gt;FP(First Paint) : 흰 화면에서 화면에 무언가가 처음으로 그려지기 시작하는 순간&lt;/li&gt;
&lt;li&gt;FCP(First Contentful Paint) : 텍스트나 이미지가 출력되기 시작하는 순간&lt;/li&gt;
&lt;li&gt;FMP(First Meaningful Paint) : 사용자에게 의미있는 콘텐츠가 그려지기 시작하는 첫 순간&lt;/li&gt;
&lt;li&gt;TTI(Time to Interactive) : 자바스크립트의 초기 실행이 완료되어서 사용자가 직접 행동을 취할 수 있는 순간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;성능 측정 도구&lt;/h3&gt;
&lt;p&gt;크롬 브라우저에서는 개발자 도구를 제공하며, 이 개발자 도구를 사용해 성능을 측정하고 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Performance 패널
&lt;ul&gt;
&lt;li&gt;웹 페이지 로딩 단계를 차트 형태로 살펴볼 수 있다.&lt;/li&gt;
&lt;li&gt;웹 페이지가 로드되는 과정을 레코딩하고 단계마다 걸리는 시간을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;로딩 과정에서 최적화가 필요한 부분을 찾을 때 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Network 패널
&lt;ul&gt;
&lt;li&gt;웹 페이지가 로딩되는 동안 요청된 리소스의 상태를 차트 형태로 확인할 수 있으며, 리소스 최적화 상태를 비교할 때 사용한다.&lt;/li&gt;
&lt;li&gt;Performance 패널과 같이 레코딩하고, 레코딩이 끝나면 overview와 Request Table에 리소스 요청 정보가 나타난다. 이때 리소스 목록은 시간순으로 정렬된다.&lt;/li&gt;
&lt;li&gt;차트 부분을 선택하면 각 리소스의 서버 요청 대기 시간을 자세히 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LightHouse
&lt;ul&gt;
&lt;li&gt;사용자 기준의 성능 측정 지표를 확인할 수 있다. 화면은 크게 성능 측정 전후로 나뉘는데, 측정 전 화면에서는 어떤 환경에서 성능을 측정할지 선택할 수 있다.&lt;/li&gt;
&lt;li&gt;느린 네트워크 환경의 시뮬레이션이 필요하다면 Throttling 영역을 설정한다.&lt;/li&gt;
&lt;li&gt;Opportunities: 최적화 가능한 리소스 목록을 보여주는 영역&lt;/li&gt;
&lt;li&gt;Diagnostics: 리소스 최적화 외에 성능을 개선할 수 있는 부분을 진단하고 해결 방안을 목록으로 보여주는 영역&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;웹 페이지 로딩 최적화&lt;/h2&gt;
&lt;h3&gt;블록 리소스 최적화&lt;/h3&gt;
&lt;p&gt;브라우저 로딩 과정에서 파싱 중 블록 리소스가 발생할 수 있으며, CSS와 JS가 블록 리소스에 해당한다. 최적화의 첫번째 단계는 이 블록 리소스를 최적화하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS 최적화
&lt;ul&gt;
&lt;li&gt;DOM 트리는 파싱 중에 태그를 발견할 때마다 순차적으로 구성할 수 있지만, CSSOM은 CSS를 모두 해석해야 구성할 수 있다. 즉, CSSOM 트리가 구성되지 않으면 렌더 트리를 만들지 못하고 렌더링이 차단된다.&lt;/li&gt;
&lt;li&gt;CSS는 렌더링 차단 리소스라고 하며, 렌더링이 차단되지 않도록 CSS는 항상 HTML문서 최상단&lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&gt;&lt;/code&gt;아래 에 배치한다.&lt;/li&gt;
&lt;li&gt;외부 스타일시트를 가져올 때 사용하는 &lt;code class=&quot;language-text&quot;&gt;@import&lt;/code&gt; 사용은 피한다. 브라우저는 스타일시트를 병렬로 다운로드 할 수 없기 때문에 로드시간이 늘어 날 수 있다. 내부 스타일시트를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;자바스크립트 최적화
&lt;ul&gt;
&lt;li&gt;자바스크립트는 DOM트리와 CSSOM트리를 동적으로 변경할 수 있기 떄문에 HTML 파싱을 차단하는 블록 리소스다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&gt;&lt;/code&gt;태그를 만나면 스크립트가 실행되며 그 이전까지 생성된 DOM에만 접근할 수 있다. 그리고 스크립트 실행이 완료될 때까지 DOM 트리 생성은 중단된다. 자바스크립트도 렌더링 차단 리소스라고하며, HTML문서 최하단 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;/body&gt;&lt;/code&gt;직전에 배치한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;리소스 요청 수 줄이기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이미지 스프라이트
&lt;ul&gt;
&lt;li&gt;여러개 이미지를 하나로 만들고 CSS의 background-position 속성을 사용해 부분 이미지 사용하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CSS, JS 번들하기
&lt;ul&gt;
&lt;li&gt;모듈기반의 개발 방식이 등장하기 이전까지 분리된 여러개의 리소스 파일을 가져와 사용했었다. 이 경우에는 웹팩과 같은 번들러를 사용하여 CSS, 자바스크립트 파일 요청을 줄일 수 있다.&lt;/li&gt;
&lt;li&gt;번들러는 여러개의 모듈 파일을 하나로 묶어서 1개파일로 생성해주는데 이것을 번들 파일이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;작은 이미지를 HTML, CSS로 대체
&lt;ul&gt;
&lt;li&gt;웹 페이지에서 사용하는 아이콘 이미지 개수가 적은 경우, 다운로드한 이미지를 사용하는 대신 Data URI로 처리할 수 있으며, HTML,CSS에서 외부 경로로 이미지를 가져오던 부분을 Base64로 변환된 URI로 대체한다.&lt;/li&gt;
&lt;li&gt;이렇게하면 외부 이미지를 사용하기 위해 발생하는 요청 횟수를 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;리소스 용량 줄이기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;중복 코드 제거하기
&lt;ul&gt;
&lt;li&gt;자바스크립트 코드 중 자주 사용되는 코드는 utils파일로 정리해 사용한다. 용량이 늘어나는 문제를 막을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTML 마크업 최적화
&lt;ul&gt;
&lt;li&gt;태그의 중첩을 최소화하여 단순하게 구성한다. 또한 공백, 주석 등을 제거하여 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;간결한 CSS 선택자 사용
&lt;ul&gt;
&lt;li&gt;스타일을 적용할 때 간결한 CSS 선택자를 사용해 최적화한다.&lt;/li&gt;
&lt;li&gt;ID 대신 클래스 선택자를 사용하면 중복되는 스타일을 묶어서 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;압축하여 사용하기
&lt;ul&gt;
&lt;li&gt;HTML, JS, CSS 모두 압축해서 사용할 수 있으며, 불필요한 주석이나 공백 등을 제거한 다음 난독화하여 사용한다.&lt;/li&gt;
&lt;li&gt;웹팩 플러그인과 같은 도구로 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ui.toast.com/fe-guide/ko_PERFORMANCE#%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95-%EB%8F%84%EA%B5%AC&quot;&gt;https://ui.toast.com/fe-guide/ko_PERFORMANCE#성능-측정-도구&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;https://d2.naver.com/helloworld/59361&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[모듈]]></title><description><![CDATA[여러 기능들에 관한 코드가 모여있는 하나의 파일 시스템을 이루는 논리적인 일부분 장점 유지보수성 네임스페이스화 재사용성 모듈이 없다면? 전역 스코프 오염 예측하기 어렵고 오류를 만든다. 변수 충돌, 로딩 순서 취약 IIFE…]]></description><link>https://sumzi.github.io/javascript/module/</link><guid isPermaLink="false">https://sumzi.github.io/javascript/module/</guid><pubDate>Sun, 23 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;여러 기능들에 관한 코드가 모여있는 하나의 파일&lt;/li&gt;
&lt;li&gt;시스템을 이루는 논리적인 일부분&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;유지보수성&lt;/li&gt;
&lt;li&gt;네임스페이스화&lt;/li&gt;
&lt;li&gt;재사용성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;모듈이 없다면?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;전역 스코프 오염&lt;/li&gt;
&lt;li&gt;예측하기 어렵고 오류를 만든다.&lt;/li&gt;
&lt;li&gt;변수 충돌, 로딩 순서 취약&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;IIFE 방식의 모듈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;위의 문제를 예방하기 위해 스코프를 사용한다.&lt;/li&gt;
&lt;li&gt;함수 스코프를 만들어 외부에서 안으로 접근하지 못하도록 공간을 격리한다.&lt;/li&gt;
&lt;li&gt;스코프 외부로부터 독립적인 스코프를 만들어 사용하여 전역변수 오염을 방지한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var math = math || {} // math 네임스페이스

(function () {
  function sum(a, b) {
    return a + b
  }
  math.sum = sum // 네임스페이스에 추가
})()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;다양한 모듈 스펙&lt;/h2&gt;
&lt;h3&gt;CommonJs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt; module.exports&lt;/code&gt; 키워드로 모듈을 만들고 &lt;code class=&quot;language-text&quot;&gt;require()&lt;/code&gt; 함수로 불러 들이는 방식&lt;/li&gt;
&lt;li&gt;모든 파일이 로컬에 존재하여 바로 불러올 수 있음을 전제로 하며, 동기적으로 동작한다.&lt;/li&gt;
&lt;li&gt;대표적으로 서버 사이트 플랫폼인 &lt;code class=&quot;language-text&quot;&gt;Node.js&lt;/code&gt;에서 이를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;AMD&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Asynchronous Module Definition&lt;/li&gt;
&lt;li&gt;CommonJS 그룹에서 의견이 맞지 않아 나온 사람들이 만든 그룹으로 비동기 모듈에 대한 표준안을 다루는 그룹이다.&lt;/li&gt;
&lt;li&gt;브라우저 내의 실행에 중점을 두고, 비동기로 로딩되는 환경에서 모듈을 사용하는 것이 목표다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;define&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt; 함수를 이용한다.&lt;/li&gt;
&lt;li&gt;구현한 유명한 스크립트가 &lt;code class=&quot;language-text&quot;&gt;RequireJS&lt;/code&gt;가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;UMD&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Universal Module Definition&lt;/li&gt;
&lt;li&gt;AMD기반으로 CommonJS 방식까지 지원하는 통합 형태다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ESM(ECMAScript Module)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트에서 모듈 사용 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;export&lt;/code&gt; 구문으로 모듈을 만들고 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt; 구문으로 가져올 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&gt;&lt;/code&gt;태그로 로딩할 때 &lt;code class=&quot;language-text&quot;&gt;type=&quot;module&quot;&lt;/code&gt;을 사용한다.&lt;/li&gt;
&lt;li&gt;독자적인 모듈 스코프를 갖는다.&lt;/li&gt;
&lt;li&gt;모든 파일을 네트워크 통신을 통해 가져와야한다.
&lt;ul&gt;
&lt;li&gt;파일을 하나하나 가져옴&lt;/li&gt;
&lt;li&gt;js뿐만 아니라 css, 이미지, font 파일도 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;모듈 번들러가 필요하다…&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Module Bundler&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;웹 애플리케이션을 구성하는 자원(HTML, CSS, JS, Image 등)을 모두 각각의 모듈로 보고, 이를 조합해서 병합된 하나의 결과물을 만드는 도구다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Webpack&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프론트엔드 프레임워크에서 많이 사용되는 모듈 번들러이다.&lt;/li&gt;
&lt;li&gt;의존 관계를 가지고 있는 javascript, css, image 등의 리소스드를 하나의 파일로 번들링하게 도와준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;webpack이 해결하려는 문제&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;자바스크립트 스코프&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여러개의 자바스크립트에서 파일에서 선언된 변수와 함수들이 전역적으로 설정되면 그만큼 충돌이나 로딩 순서 등에 취약하다.&lt;/li&gt;
&lt;li&gt;이를 모듈이라는 단위로 관리할 수 있게 도와준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;브라우저별 HTTP 요청 숫자의 제약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에서 한번에 서버로 보낼 수 있는 HTTP 요청 숫자는 제약되어 있다.&lt;/li&gt;
&lt;li&gt;웹팩을 통해 번들링하면 요청해야하는 파일의 수가 적어지므로 더 빠른 성능 개선이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamic Loading &amp;#x26; Lazy Loading&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SPA의 단점으로 초기에 필요하지 않은 페이지에 대한 스크립트들도 불러온다.&lt;/li&gt;
&lt;li&gt;웹팩을 통해 모듈 번들링을 이용하면 동적으로, 필요한 페이지에 따른 스크립트 모듈을 동적으로 불러오는 것도 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 개발 작업 자동화&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML, CSS, JS 압축&lt;/li&gt;
&lt;li&gt;이미지 압축&lt;/li&gt;
&lt;li&gt;CSS 전처리기 변환&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;entry/output&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;--mode&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;--entry&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;--output&lt;/code&gt; 세 개 옵션만 사용하면 코드를 묶을 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;--mode&lt;/code&gt;: 웹팩 실행 모드를 의미, development, production, null이 있음&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;--entry&lt;/code&gt;: 시작점 경로를 지정하는 옵션&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;--output&lt;/code&gt;: 번들링 결과물을 위치할 경로&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Loader&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹팩이 자바스크립트 파일이 아닌 웹자원(HTML, CSS, image, font)을 변환할 수 있도록 도와준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;css-loader&lt;/code&gt; : css 파일을 모듈로서 가져올 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;style-loader&lt;/code&gt; : css를 html에 넣어 브라우저 렌더링 시 적용될 수 있게 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;file-loader&lt;/code&gt; : 이미지를 모듈로 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Plugin&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;로더가 해석하고 변환한 결과물의 형태를 바꾼다. 즉, 후처리하는 역할&lt;/li&gt;
&lt;li&gt;난독화, 특정 문자열 치환 등을 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;defineplugin&lt;/code&gt; : 환경 의존적인 정보를 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Babel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;서로 다른 브라우저 스펙으로 인해 하나의 프로젝트 코드로 모든 브라우저를 커버하지 못하게 되는 크로스 브라우징 문제를 해결해준다.&lt;/li&gt;
&lt;li&gt;최신 스펙을 사용해서 코드를 작성해도 브라우저마다 동일하게 동작하도록 도와준다.&lt;/li&gt;
&lt;li&gt;코드 변환 3단계
&lt;ol&gt;
&lt;li&gt;토큰 분해&lt;/li&gt;
&lt;li&gt;ES5 스펙으로 변환&lt;/li&gt;
&lt;li&gt;코드 출력&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html&quot;&gt;https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@chullino/%EC%9B%B9%ED%8C%A9-3-4-js%EB%AA%A8%EB%93%88%ED%99%94-%EC%97%AD%EC%82%AC-%EB%8F%8C%EC%95%84%EB%B3%B4%EA%B8%B0-1-9df997f82002&quot;&gt;https://medium.com/@chullino/%EC%9B%B9%ED%8C%A9-3-4-js%EB%AA%A8%EB%93%88%ED%99%94-%EC%97%AD%EC%82%AC-%EB%8F%8C%EC%95%84%EB%B3%B4%EA%B8%B0-1-9df997f82002&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-module&quot;&gt;https://poiemaweb.com/es6-module&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[CI와 CD]]></title><description><![CDATA[CI와 CD CI/CD란? 개발부터 배포까지의 과정을 자동화하여 개발된 내용이 사용자에게 빠르게 도달할 수 있게 해주는 방법론 CI (Continuous Integration…]]></description><link>https://sumzi.github.io/web/ci-cd/</link><guid isPermaLink="false">https://sumzi.github.io/web/ci-cd/</guid><pubDate>Thu, 13 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;CI와 CD&lt;/h1&gt;
&lt;h2&gt;CI/CD란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;개발부터 배포까지의 과정을 자동화하여 개발된 내용이 사용자에게 빠르게 도달할 수 있게 해주는 방법론&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CI (Continuous Integration)&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c54c5189555d23582f59f0cda2743cf8/1c58d/ci-cd1.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 26.58227848101266%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAID/9oADAMBAAIQAxAAAAHRkAnT/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAMCERMS/9oACAEBAAEFAuJGbLzYf//EABgRAAIDAAAAAAAAAAAAAAAAAAABAhIh/9oACAEDAQE/AY4WZ//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPwGsf//EABkQAAIDAQAAAAAAAAAAAAAAAAABAzORIf/aAAgBAQAGPwKwueHJnh//xAAZEAADAAMAAAAAAAAAAAAAAAAAAREhMXH/2gAIAQEAAT8hbXavDPYZ6SP/2gAMAwEAAgADAAAAEAQ//8QAGREAAwADAAAAAAAAAAAAAAAAAAERcZHR/9oACAEDAQE/EGqoxaXD/8QAFhEBAQEAAAAAAAAAAAAAAAAAABEh/9oACAECAQE/ENIf/8QAHRABAAEDBQAAAAAAAAAAAAAAAQARIUExUWFx0f/aAAgBAQABPxAKRFL8S+cxQJLXDSncLbYQPZ//2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cicd&quot;
        title=&quot;cicd&quot;
        src=&quot;/static/c54c5189555d23582f59f0cda2743cf8/828fb/ci-cd1.jpg&quot;
        srcset=&quot;/static/c54c5189555d23582f59f0cda2743cf8/ff44c/ci-cd1.jpg 158w,
/static/c54c5189555d23582f59f0cda2743cf8/a6688/ci-cd1.jpg 315w,
/static/c54c5189555d23582f59f0cda2743cf8/828fb/ci-cd1.jpg 630w,
/static/c54c5189555d23582f59f0cda2743cf8/1c58d/ci-cd1.jpg 826w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지속적인 통합&lt;/li&gt;
&lt;li&gt;어플리케이션에 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;CI 장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;버그를 신속하게 찾아 해결&lt;/li&gt;
&lt;li&gt;테스트 코드를 통과한 코드만이 레포지터리에 올라가기 때문에 소프트웨어 품질 개선, 향상&lt;/li&gt;
&lt;li&gt;좋은 코드 퀄리티 유지&lt;/li&gt;
&lt;li&gt;새로운 업데이트의 검증 및 릴리즈의 시간 단축, 개발 편의성 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CD (Continuous Delivery/Deployment)&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f296b5b78adae894d743b08415ff6d00/4b190/ci-cd2.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 112.65822784810126%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAIBAwT/xAAYAQACAwAAAAAAAAAAAAAAAAABAgADBP/aAAwDAQACEAMQAAAB9E9NbLCjVTpDII//xAAZEAADAQEBAAAAAAAAAAAAAAAAAREQEiH/2gAIAQEAAQUC5YlSFH5lyn//xAAbEQACAQUAAAAAAAAAAAAAAAAAAQIQERIhMf/aAAgBAwEBPwHDhLTLun//xAAZEQACAwEAAAAAAAAAAAAAAAAAARAREjH/2gAIAQIBAT8B10RSj//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABwQAAIDAAMBAAAAAAAAAAAAAAERACExEEFRYf/aAAgBAQABPyF5oblwjK19jDZWlC8xu4G6hL3h/9oADAMBAAIAAwAAABDE8H3/xAAYEQADAQEAAAAAAAAAAAAAAAAAAREhYf/aAAgBAwEBPxBahPTQiU4PXT//xAAZEQEAAwEBAAAAAAAAAAAAAAABABExUWH/2gAIAQIBAT8QyuRWDNvYFFT/xAAcEAEBAQACAwEAAAAAAAAAAAABEQAhUTFBgXH/2gAIAQEAAT8QnfERdy6UjHw9aOEH9uT9XOQVDeMC4l9Yg2Ht3lcp3p6Tf//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cicd&quot;
        title=&quot;cicd&quot;
        src=&quot;/static/f296b5b78adae894d743b08415ff6d00/828fb/ci-cd2.jpg&quot;
        srcset=&quot;/static/f296b5b78adae894d743b08415ff6d00/ff44c/ci-cd2.jpg 158w,
/static/f296b5b78adae894d743b08415ff6d00/a6688/ci-cd2.jpg 315w,
/static/f296b5b78adae894d743b08415ff6d00/828fb/ci-cd2.jpg 630w,
/static/f296b5b78adae894d743b08415ff6d00/4b190/ci-cd2.jpg 800w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지속적인 제공 &amp;#x26; 지속적인 배포 두 가지 모두를 뜻함&lt;/li&gt;
&lt;li&gt;빌드의 결과물을 프로덕션으로 릴리스하는 작업을 자동화하는 것&lt;/li&gt;
&lt;li&gt;CD는 두가지로 구분할 수 있다.
&lt;ul&gt;
&lt;li&gt;지속적 제공(Delivery), 지속적 배포(Deployment)&lt;/li&gt;
&lt;li&gt;둘의 차이점은 배포 작업의 자동화 여부이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Continuous Delivery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;지속적인 제공&lt;/li&gt;
&lt;li&gt;공유 레포지토리로 자동으로 Release 하는 것, 배포 자체는 수동으로 실행한다.&lt;/li&gt;
&lt;li&gt;바로 배포할 수 있는 코드베이스를 확보하는 것이 목적&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Continuous Deployment&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;지속적인 배포&lt;/li&gt;
&lt;li&gt;Continuous Delivery의 파이프라인 통과 + Production에 자동으로 배포한다.&lt;/li&gt;
&lt;li&gt;어플리케이션의 제공 속도를 증가시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;차이점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Continuous Delivery : 프로덕션 배포는 수동 (배포 과정은 자동화)&lt;/li&gt;
&lt;li&gt;Continuous Deployment : 프로덕션 배포까지 자동화&lt;/li&gt;
&lt;li&gt;일반적으로 자동 배포까지의 과정을 통칭하지만, 어디까지 자동화가 이루어져 있는지를 설명하기 위해 별도로 구분함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;CD 장점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;개발자는 배포보다는 개발에 더욱 신경 쓸 수 있도록 도와준다.&lt;/li&gt;
&lt;li&gt;개발자가 수작업 없이 빌드, 테스트, 배포까지의 자동화를 할 수 있다.&lt;/li&gt;
&lt;li&gt;서비스의 사용자는 최대한 빠른 시간 내에 최신 버전의 Production을 제공받을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;요약&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CI는 빌드 및 테스트 후 코드를 지속적인 통합하는 것&lt;/li&gt;
&lt;li&gt;Continuous Delivery는 CI를 통해 통합된 코드를 즉시 출시 가능한 상태로 준비해 놓는 것&lt;/li&gt;
&lt;li&gt;Continuous Deployment는 CI를 통해 통합된 코드를 프로덕션에 즉시 배포하는 것&lt;/li&gt;
&lt;li&gt;CI/CD는 팀마다 다르다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.redhat.com/ko/topics/devops/what-is-ci-cd&quot;&gt;https://www.redhat.com/ko/topics/devops/what-is-ci-cd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=0Emq5FypiMM&quot;&gt;https://www.youtube.com/watch?v=0Emq5FypiMM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Github Actions로 자동 배포하기]]></title><description><![CDATA[GitHub Actions란? GitHub Actions는 GitHub에서 제공하는 CI(Continuous Integration)와 CD(Continuous Deployment…]]></description><link>https://sumzi.github.io/git/github-actions/</link><guid isPermaLink="false">https://sumzi.github.io/git/github-actions/</guid><pubDate>Tue, 11 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;GitHub Actions란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Actions는 GitHub에서 제공하는 CI(Continuous Integration)와 CD(Continuous Deployment)를 위한 서비스&lt;/li&gt;
&lt;li&gt;자동으로 코드 저장소에서 어떤 이벤트가 발생했을 때 특정 작업이 일어나게 하거나 주기적으로 어떤 작업들을 반복해서 실행시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;핵심 개념&lt;/h2&gt;
&lt;h3&gt;Workflows&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Actions에서 가장 상위 개념인 워크플로우는 자동화 해높은 작업 과정&lt;/li&gt;
&lt;li&gt;코드 저장소 내에서 &lt;code class=&quot;language-text&quot;&gt;.github/workflows&lt;/code&gt; 폴더 아래에 위치한 YAML 파일로 설정하며, 하나의 코드 저장소에 여러개의 워크플로우 YAML 파일 생성 가능하다.&lt;/li&gt;
&lt;li&gt;크게 2가지를 정의해야함
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;on&lt;/code&gt; : 해당 워크플로우가 언제 실행되는지 정의&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;jobs&lt;/code&gt; : 해당 워크플로우가 구체적으로 어떤 일을 해야하는지 명시해야함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;on:
  push:
    branches:
      - main

jobs:
  # ...(생략)...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;코드 저장소의 &lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt; 브랜치에 &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; 이벤트가 발생할 때마다 작업을 실행함&lt;/p&gt;
&lt;h3&gt;Jobs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작업이란 독립된 가상머신 또는 컨테이너에서 돌아가는 하나의 처리 단위를 의미&lt;/li&gt;
&lt;li&gt;작업의 세부 내용으로 필수로 들어가야하는 &lt;code class=&quot;language-text&quot;&gt;runs-on&lt;/code&gt; 속성을 통해 해당 리눅스나 윈도우즈와 같은 실행 환경을 지정해야함&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# ...(생략)...

jobs:
  job1:  // 여러 작업을 수행 가능
    runs-on: ubuntu-latest
    steps:
      # ...(생략)...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Steps&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;각 작업이 하나 이상의 단계로 모델링&lt;/li&gt;
&lt;li&gt;커맨드나 스크립트를 실행할 때는 &lt;code class=&quot;language-text&quot;&gt;run&lt;/code&gt;속성을 사용하며, 액션을 사용할 때는 &lt;code class=&quot;language-text&quot;&gt;uses&lt;/code&gt;속성을 사용함&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# ...(생략)...

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm install
      - run: npm test&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;워크플로우 파일 내에서 작업 단계를 명시해 줄 때는 각 단계 앞에 반드시 &lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt;를 붙여야함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Actions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;액션은 GitHub Actions에서 빈번하게 필요한 반복 단계를 재사용하기 용이하도록 제공되는 일종의 작업 공유 메커니즘&lt;/li&gt;
&lt;li&gt;하나의 코드 저장소 범위 내에서 여러 워크플로우 간에서 공유, 공개 코드 저장소를 통해 액션을 공유하면 GitHub상의 모든 코드 저장소에서 사용가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;GiHub Actions로 gh-pages 자동 배포하기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;정적 파일을 master branch에 push하면 자동으로 빌드되고 그 결과물을 gh-pages branch에 올려서 배포해보자&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.github/workflows&lt;/code&gt; 폴더에 &lt;code class=&quot;language-text&quot;&gt;.yml&lt;/code&gt; 파일을 추가, 위크플로우 생성&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해당 브랜치에 &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt;할 때 실행되는 &lt;code class=&quot;language-text&quot;&gt;jobs&lt;/code&gt;을 작성&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt; name: Deploy to GitHub Pages

 on:
   push:
     branches:
       - master

 jobs:
   deploy:
     runs-on: ubuntu-latest

     steps:
       - uses: actions/checkout@v2
       - uses: actions/setup-node@v3
         with:
           node-version: 18
           cache: npm

       - name: Install dependencies
         run: npm install --frozen-lockfile

       - name: Build website
         run: npm run build

       - name: Deploy to GitHub Pages
         uses: peaceiris/actions-gh-pages@v3
         with:
           github_token: ${{ secrets.GITHUB_TOKEN }}
           publish_dir: ./build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Personal access tokens 생성하기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Settings &gt; Developer settings &gt; Personal access tokens&lt;/li&gt;
&lt;li&gt;New personal access token 생성&lt;/li&gt;
&lt;li&gt;Select scopes 에서 repo 체크&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;token을 Secrets Actions에 추가하기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해당 repository에서 Settings &gt; Secrets &gt; Action&lt;/li&gt;
&lt;li&gt;Repository secrets에 키와 값을 입력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.daleseo.com/github-actions-basics/&quot;&gt;https://www.daleseo.com/github-actions-basics/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@kdeun1/Github-Actions%EB%A1%9C-gh-pages-%EC%9E%90%EB%8F%99-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0&quot;&gt;https://velog.io/@kdeun1/Github-Actions%EB%A1%9C-gh-pages-%EC%9E%90%EB%8F%99-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>